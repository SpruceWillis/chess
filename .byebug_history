q!
self[start_pos[0], end_pos[1]]
end_pos
start_pos
q!
exit
@prev_move[:end_pos]
pos
s
c
c 
c
s
c
s
c
q!
dx
self[end_pos].is_a?(Pawn)
(pos[1] - end_pos[1])
pos[1] - end_pos[1]
pos[0] - end_pos[0]
pos[0] - end_pos[0
pos[0]
dy
@prev_move[:end_pos]
@prev_move
pos
dx
s
dx
@prev_move
s
self
slef
pos
s
c
q!
x
c
q!
c
s
where
b
@prev_move
pos
exit
@display.render
n
exit
n
exit
n
resp
c
exit
end_pos
resp
c
exit
dy
n
row
n
row
c
s
exit
row
@board[[row,5]].empty?
s
piece.has_moved
piece.class
piece
c
s
exit
s
end_pos
exit
test_board.render
exit
test_board.render
test_board
test_board[pos]
move
pos
exit
delta
s
@board[[2,0]].empty?
@board[2,0].empty?
delta
start_pos
s
delta
exit
directions
delta
s
exit
step_direction
step_dir
start_pos
y
x
s
step_direction
s
step_direction
exit
var_dir
exit
var
move_arr
exit
end_pos
start_pos
move_arr
